## 谈谈我对闭包的理解
在网上查找了很多的关于JS闭包的资料，奈何本人的理解程度实在捉急，看的都是一头雾水。直到后面接触到了一本书叫《HEAD FIRST JavaSCript Programming》（很多插图的那种书），对小白非常友好。
在第11章节中，单独对闭包做了一些解释。例如作者和他们的团队是这样定义或总结闭包规律的：

**包含自由变量的函数与为所有这些自由变量提供了变量绑定的环境一起，被称为闭包**;

这句话里面涉及到了两个词，即`自由变量`和`环境`,也就是说只要先了解这两个词，就差不多能搞懂闭包，下面结合代码一一探讨：

自由变量：自由变量是指在函数中使用的，但既不是函数参数也不是函数的局部变量的变量；在代码中来理解：
```js
let a = 1;

function foo() {
  console.log(a); // a 在这里就是一个自由变量
}

foo();
```
在上述代码中，当调用`foo()`函数时，取 `a` 的值时，由于变量`a`没有在`foo`函数中声明（在其他作用域中声明的,这里是`foo`函数外部的定义的全局变量`a`），对于这个函数来说，这个变量就是一个自由变量。

环境：为自由变量提供变量绑定的环境（或者说能创建使得自由变量能工作的环境）；使用另一段代码来理解：
```js
let x = 100;

let foo = function(){
  console.log(x);   // x 为自由变量
}

function fn(fun){
  let x = 10;
  (function(){
    fun();
  })()
}

fn(foo);
```
在这段代码中，当调用`fn()`函数并传入函数的引用`foo`作为参数时，由于`fn(fun)`函数中嵌套了一个匿名函数自执行，并且这个函数是对传入的函数引用`foo`进行函数调用;在`foo`函数体中，x为自由变量，当函数被调用时，会创建一个包含全局变量的 x=100 的环境，这个环境是能给所有自由变量（这里代码只有 x 一个自由变量）都提供了值的环境，被称为是可`“敲定”`（close）函数的环境；这就是所谓的`词法作用域`，所以函数`foo`被调用之后取x的值就在一个包含自由变量的环境中取，即 x = 100;

## 实践中的闭包
使用闭包实现计数器

示例代码：
```js
function makeCounter() {
    let count  = 0;
    function counter() {
        count += 1;       // count 为自由函数
        return count;
    }
    return counter;     // 构成闭包，在其环境中存储了变量count
    
}

let doCounter = makeCounter();
console.log(doCounter()); // > 1
console.log(doCounter()); // > 2
console.log(doCounter()); // > 3
```
上述代码中，makeCounter 函数执行后返回了一个函数名为 counter 的函数引用并赋值给另一个变量 doCounter，该函数引用了自由变量 count，而在 makeCounter() 执行完毕后，创建该函数的环境已经销毁，但该函数并没有被销毁，因此 makeCounter() 的返回值就是一个闭包：一个函数及其环境;闭包会使引用的自由变量不能被清除，所以每一次执行 doCounter() 完毕时，自由变量 count 会自增1，这就使得闭包比其他函数占用内存更多，但这也是闭包的强大之处。

// TODO: 待理解解决

再来看一个面试中经常遇到的题目：
```js
let data = [];

for (var i = 0; i < 3; i++) {
  data[i] = function () {
    console.log(i);
  };
}

data[0](); // 3
data[1](); // 3
data[2](); // 3
```
这三个函数创建时均使用的是已经在上下文中静态保存好的变量 i，而在 for 循环结束时，变量i 的值为3，当 data[0]() 执行时，其所引用的自由变量 i 的值为 3，因此输出3。

我们的目标是输出0、1、2，上面的例子显然无法实现这个需求，利用闭包可以很轻松地解决这个问题：
```js
let data = [];

for (let i = 0; i < 3; i++) {
  data[i] = (function(x) {
    return function () {
      alert(i);
    };
  })(i); // 传入"i"值
}

data[0](); // 0
data[1](); // 1
data[2](); // 2
```
以上就是关于js自由变量与闭包全部内容，希望对大家有帮助。

## Q & A
为什么说所有函数其实都是闭包？

答：在ECMAScript中，闭包（Closure）是指能够访问自由变量的函数。

按照以上的概念，我们可以说所有函数都是闭包，因为它们都是在创建的时候就保存了上层上下文的作用域链，观察如下代码：
```js
let a = 1;

function foo() {
  console.log(a);
}

foo(); // > 1

(function () {

  let a = 2;
  foo(); // > 1

})();
```
ECMAScript 使用的是词法作用域（Lexical scoping，又称静态作用域），即在函数创建时，就保存上层上下文的作用域链，上述代码中，foo 函数创建时，其所使用的变量 a 是已经在上下文中静态保存好的，因此在执行 foo() 时 a 的值为 1。

而任何函数，在其创建时保存的上层上下文的作用域中都有全局的自由变量 global（在浏览器中，global 为 window），因此说所有函数都是闭包。

## 引用
- [js中自由变量与闭包](https://www.mybj123.com/16908.html)